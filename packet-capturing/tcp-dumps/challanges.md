# Challanges

## PCAP 19

In this challenge, the file only contains a single HTTP request. The key is available in the body of the response as part of the HTML code. However this time, the response is gzip'ed. This compression is used to limit the amount of data that needs to be transfered.

## PCAP 20

In this challenge, the file only contains a single HTTP request. The key is available in the body of the response as part of the HTML code. However this time, the response is gzip'ed. This compression is used to limit the amount of data that needs to be transfered.

Using Wireshark, you can open the file. Once the file is loaded, you should be able to right-click and select "Follow" -> "TCP Stream". This command will open a new window with the full TCP connection. This command basically reconstruct the connection so you're able to inspect the data without having to worry about the lower layer (IP and ARP). Then you need to select "Show and save data as" and select "RAW", then you can click on the "Save as..." button. Once you have the file save, you can edit it to remove everything aside from the body of the response (located after the last header). Finally, you can save the file and run gunzip on it to decompress the content and get the key

## PCAP 21

In this challenge, the file only contains a single HTTP request. The key is available in the body of the response as part of the HTML code. However this time, the response is deflated. This compression is used to limit the amount of data that needs to be transfered.

Using Wireshark, you can open the file. Once the file is loaded, you should be able to right-click and select "Follow" -> "TCP Stream". This command will open a new window with the full TCP connection. This command basically reconstruct the connection so you're able to inspect the data without having to worry about the lower layer (IP and ARP). Then you need to select "Show and save data as" and select "RAW", then you can click on the "Save as..." button. Once you have the file save, you can edit it to remove everything aside from the body of the response (located after the last header). Finally, you can save the file and run gunzip on it to decompress the content and get the key. However, since the content is deflate instead of simply gzip, you will need to add some magic bytes to the response to get gunzip working:

printf "\x1f\x8b\x08\x00\x00\x00\x00\x00"  | cat - pcap_21_extracted_body | gunzip
Where pcap_21_extracted_body is the file containing the body of the response.

## PCAP 22

In this challenge, the file only contains a single HTTP request. The key is available in the body of the response as part of the HTML code. However this time, the response is chunk-encoded. This doesn't really change your ability to see the key. But you can observe that there is no Content-Length header and some hexadecimal number in the body. The idea behind chunk-encoding is that the server can send content without waiting for the full response to be ready. The server sends the size of a chunk (in hexadecimal) followed by the chunk.

## PCAP 24

In this challenge, the file only contains a single DNS query and the matching answer. You can see that this time UDP is used. You can still inspect the traffic to get the key in both the query and the answer. In this sample, the client asks for an A record to get the IP address corresponding to a given hostname (the hostname being the key to solve this exercise).

## PCAP 27

In this challenge, the file contains multiple DNS packets. One common issue with IoT devices is that they use a predictable transaction ID (a random number). The transaction ID is used to protect the client from an attacker sending malicious response. Since the attacker may not be able to intercept the query (for example if the attacker is on the same network but not in the middle), the attacker cannot predict the transaction ID and respond with a valid response. IoT devices can suffer from one of the following issues:

Using a transaction ID that is fixed (for example only 0).
Using a transaction ID that is very predictable (Or incremental).
Not checking the transaction ID from the response to ensure it's the one matching the query they sent.
In this example, we will cover the first case (fixed transaction ID set to 0. You need to find the DNS query with the right transaction ID and the hostname is the key to solve this exercise (without the domain).

## PCAP 28

In this challenge, the file contains multiple DNS packets. We can see that an attacker is trying to inject DNS response but the attacker cannot predict the transaction ID. You need to find the response matching the query from the actual client.

## PCAP 29

In this challenge, the file contains an ICMP request and reply (a "ping"). ICMP can be used as a covert channel to send information from one system to another without raising alarms. Here the key to solve this exercise is embedded in the ICMP request.

## PCAP 30

In this challenge, the file contains a TLS connection. The client is connecting to the server and getting the certificate as part of the Server Hello (as a response to the Client Hello. In the Server Hello you can find a lot of information about the server, including the certificate and the Common Name (or CN) of the server's certificate. The key to solve this exercise is the CN (without .pentesterlab.com).

## PCAP 31

In this challenge, the file contains a TLS connection. The client is connecting to the server and sending a Client Hello. Since a single IP may host multiple TLS server on the same port, the server needs to know what certificate it needs to send to the client. If the server sends the wrong certificate (for example by sending a valid certificate for pentesterlab.com when the client tries to access ptl.io), the client will reject it. However, there is no way at the TCP level to know what TLS server the client tries to connect to. Thankfully, the client can use a TLS extension named Server Name Indication or S.N.I. as part of the Client Hello. The key to this challenge is the S.N.I. value sent by the client (without .pentesterlab.com).

## PCAP 32

In this challenge, the file contains a TLS connection. The connection is encrypted using TLS. However, you should be able to decrypt it using the private key. To do so you need to select one of the TLS packets and right-click to go to Protocol Preferences then RSA keys list. From there you can feed all the details: IP address, port, protocol (use http or tcp) and the server's private key pcap_32_server_private_key.pem. Once you click Ok, you should see the decrypted traffic that contains the key to solve this exercise.

You are able to decrypt this TLS connection because the server does not use Forward Secrecy. In the next challenge, we will look at how it can be done with Forward Secrecy.

## PCAP 33

In this challenge, the file contains a TLS connection. The connection is encrypted using TLS. This time, the connection uses Forward Secrecy (you can compare the Cipher Suite in the Server Hello between pcap_32.pcap and pcap_33.pcap. Since Forward Secrecy is used, you cannot decrypt the connection with the server's private key. This ensures that if the server's private key is compromised, someone sniffing the traffic prior to the compromise cannot recover the cleartext traffic.

However, by modifying the client or the server, it's possible to retrieve the pre-shared key used to secure the communication: pcap_33_premaster.txt. Here, you can use this key to decrypt the communication. To do this, you can follow the following steps: right-click on a TLS packet, select "Protocol Preferences", then SSL debug file. Then, you can just pick the file pcap_33_premaster.txt using the (Pre)-Master-Secret log filename field. You should then get access to the cleartext traffic that contains the key.

## PCAP 34

In this challenge, the file contains a TLS connection. The client is connecting to the server. This time the client sends a client certificate to authenticate against the server. You can find the certificate as part of the Certificate, Client Key Exchange message from the client. The key to solve this challenge is the common name used by the client.

## PCAP 35

In this challenge, the file contains a connection to a MySQL server as well as a query and response (on top of the ones done by the client). The key to solve this exercise is the password field for the admin user in the SQL response.


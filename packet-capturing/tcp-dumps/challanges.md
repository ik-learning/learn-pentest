# Challanges

## PCAP 19

In this challenge, the file only contains a single HTTP request. The key is available in the body of the response as part of the HTML code. However this time, the response is gzip'ed. This compression is used to limit the amount of data that needs to be transfered.

## PCAP 20

In this challenge, the file only contains a single HTTP request. The key is available in the body of the response as part of the HTML code. However this time, the response is gzip'ed. This compression is used to limit the amount of data that needs to be transfered.

Using Wireshark, you can open the file. Once the file is loaded, you should be able to right-click and select "Follow" -> "TCP Stream". This command will open a new window with the full TCP connection. This command basically reconstruct the connection so you're able to inspect the data without having to worry about the lower layer (IP and ARP). Then you need to select "Show and save data as" and select "RAW", then you can click on the "Save as..." button. Once you have the file save, you can edit it to remove everything aside from the body of the response (located after the last header). Finally, you can save the file and run gunzip on it to decompress the content and get the key

## PCAP 21

In this challenge, the file only contains a single HTTP request. The key is available in the body of the response as part of the HTML code. However this time, the response is deflated. This compression is used to limit the amount of data that needs to be transfered.

Using Wireshark, you can open the file. Once the file is loaded, you should be able to right-click and select "Follow" -> "TCP Stream". This command will open a new window with the full TCP connection. This command basically reconstruct the connection so you're able to inspect the data without having to worry about the lower layer (IP and ARP). Then you need to select "Show and save data as" and select "RAW", then you can click on the "Save as..." button. Once you have the file save, you can edit it to remove everything aside from the body of the response (located after the last header). Finally, you can save the file and run gunzip on it to decompress the content and get the key. However, since the content is deflate instead of simply gzip, you will need to add some magic bytes to the response to get gunzip working:

printf "\x1f\x8b\x08\x00\x00\x00\x00\x00"  | cat - pcap_21_extracted_body | gunzip
Where pcap_21_extracted_body is the file containing the body of the response.

## PCAP 22

In this challenge, the file only contains a single HTTP request. The key is available in the body of the response as part of the HTML code. However this time, the response is chunk-encoded. This doesn't really change your ability to see the key. But you can observe that there is no Content-Length header and some hexadecimal number in the body. The idea behind chunk-encoding is that the server can send content without waiting for the full response to be ready. The server sends the size of a chunk (in hexadecimal) followed by the chunk.

## PCAP 24

In this challenge, the file only contains a single DNS query and the matching answer. You can see that this time UDP is used. You can still inspect the traffic to get the key in both the query and the answer. In this sample, the client asks for an A record to get the IP address corresponding to a given hostname (the hostname being the key to solve this exercise).

## PCAP 27

In this challenge, the file contains multiple DNS packets. One common issue with IoT devices is that they use a predictable transaction ID (a random number). The transaction ID is used to protect the client from an attacker sending malicious response. Since the attacker may not be able to intercept the query (for example if the attacker is on the same network but not in the middle), the attacker cannot predict the transaction ID and respond with a valid response. IoT devices can suffer from one of the following issues:

Using a transaction ID that is fixed (for example only 0).
Using a transaction ID that is very predictable (Or incremental).
Not checking the transaction ID from the response to ensure it's the one matching the query they sent.
In this example, we will cover the first case (fixed transaction ID set to 0. You need to find the DNS query with the right transaction ID and the hostname is the key to solve this exercise (without the domain).

## PCAP 28

In this challenge, the file contains multiple DNS packets. We can see that an attacker is trying to inject DNS response but the attacker cannot predict the transaction ID. You need to find the response matching the query from the actual client.

## PCAP 29

In this challenge, the file contains an ICMP request and reply (a "ping"). ICMP can be used as a covert channel to send information from one system to another without raising alarms. Here the key to solve this exercise is embedded in the ICMP request.

## PCAP 30

In this challenge, the file contains a TLS connection. The client is connecting to the server and getting the certificate as part of the Server Hello (as a response to the Client Hello. In the Server Hello you can find a lot of information about the server, including the certificate and the Common Name (or CN) of the server's certificate. The key to solve this exercise is the CN (without .pentesterlab.com).

# JWT None

## Empty Signature Examples

```
Base64(Header).Base64(Data).
```

## The vulnerability
This issue was originally discussed in the following blog post: https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/.

In this article, Tim McLean discussed multiple issues in the signature mechanism used by JWT. In this exercise, we are going to focus on the first issue.

Multiple signature methods can be used to ensure the integrity of JWT:

- RSA based
- Elliptic curves
- HMAC
- None

Here, the application uses RSA. You can even download the public key if you want to be able to verify the token. Since you don't have the private key, you cannot generate a valid token (in theory). In a real scenario, you may get to get the public key from a JavaScript script or from a mobile application.

With RSA, to:

sign a token, you need the private key.
verify a token, you can use the public key corresponding to the private key used for the signature.
With HMAC, to:
* sign a token, you need the secret.
* verify a token, you need the same secret.

In practice, you can change the algorithm used by the application (RSA - RS256) to tell it to use HMAC (HS256). The application will call the method verify when you send the cookie. Since the code is written to use RSA, it will call verify(public_key, data). But since the algorithm is set to HMAC, it will end up calling HMAC(public_key,data).

The application will verify the signature with the public key but since you are forcing the application to use HMAC, it will actually verify the signature with HMAC(public_key, data). As an attacker, you have everything you need to generate a valid signature, since the public key is actually public.

Exploitation
To exploit this vulnerability, you just need to decode the JWT and change the algorithm used for the signature. Change the username to "admin". Then you can compute the new signature and submit your new JWT.

To create the correct signature, you need to look at the details of the JWT format to understand what data is signed and how it's signed. The JWT format sign the base64-URL encoded without padding (https://tools.ietf.org/html/rfc7515#appendix-C) header and the base64-URL encoded without padding data after concatenating them with a single dot ..

Conclusion
This exercise showed you how you can tamper with a JWT to gain administrator access in the application. It showed you that having a signed value is only as strong as the weakest algorithm used if an attacker can pick what algorithm is used. I hope you enjoyed learning with PentesterLab.
